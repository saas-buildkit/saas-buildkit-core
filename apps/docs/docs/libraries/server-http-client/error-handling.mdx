---
title: 'Error Handling'
---

# Error Handling

---

## Internal Proxy Http Exception

The [`InternalProxyHttpException`](/api/server-http-client/src/classes/InternalProxyHttpException/) class is central to the library's error handling mechanism. It captures HTTP errors from internal service calls and includes details such as the HTTP status, response, and original configuration.

```typescript
export class InternalProxyHttpException {
  constructor(
    public status: HttpStatus,
    public response: AxiosResponse<any>,
    public config?: object,
    public rootCause?: unknown,
  ) {}
}
```

## Exception Filter

The [`InternalProxyHttpExceptionFilter`](/api/server-http-client/src/classes/InternalProxyHttpExceptionFilter/) implements the `ExceptionFilter` interface from NestJS. It catches `InternalProxyHttpException` and uses the HTTP adapter to relay the error response to the client.

```typescript
@Catch(InternalProxyHttpException)
export class InternalProxyHttpExceptionFilter implements ExceptionFilter {
  // Filter implementation...
}
```

## Axios Integration and Error Handling Example

Imagine a scenario in a microservices architecture where a client makes a request that passes through multiple services. Let's say the client sends a request to Service 1, which in turn needs to fetch data from Service 2. However, an error occurs in Service 2.
Here's how the error is handled and propagated back to the client:

### Scenario Flow:

1. **Client Request to Service 1**: The client initiates an HTTP request to Service 1.

2. **Service 1 Calls Service 2**: Service 1 processes the request and makes a subsequent call to Service 2 using the server-http-client library.

3. **Error Occurs in Service 2**: Service 2 encounters an error during processing (e.g., a database error or a validation failure).

4. **Service 2 Responds with an Error**: Service 2 sends back an error response, which is captured by the server-http-client library in Service 1.

5. **Error Handling in Service 1**: Instead of a typical error, Service 1 receives an InternalProxyHttpException, which contains the original error details from Service 2, including the HTTP status code, response body, and any additional error information.

6. **Service 1 Rethrows the Error**: Service 1, leveraging the InternalProxyHttpExceptionFilter, rethrows the error. This ensures that the client receives the same error response as originally generated by Service 2.

7. **Client Receives the Rethrown Error**: The client receives the error response, which is identical to the one generated by Service 2, providing transparency and consistency in error handling across services.

### Example:

```plaintext
Client -> Service 1 -> [HTTP Request via server-http-client] -> Service 2
Service 2 -> [Error Response] -> Service 1 -> [Rethrows as InternalProxyHttpException] -> Client
```

## Next Steps

- [**Request ID Propagation**](/libraries/server-http-client/request-id-propagation): Learn about seamless request ID propagation across services using CLS.
